---
title: "Indices de ancestría en `tess3r`"
author: "Daniela Felix"
output:
  html_document:
    toc: true
    toc_float: true
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r libraries, message=FALSE, warning=FALSE}
library(adegenet)
library(tess3r)
library(maps)
library(ggplot2)
library(sf)
library(rnaturalearth)
library(rworldmap)
library(fields)
library(metR)
library(dplyr)
```

### Preparando nuestros datos genéticos
```{r objeto genind}
fish.ind <- readRDS(file.path("../Seccion_II/outputs/", "fish.ind.rds"))
fish.ind
```

Convertir nuestro objeto genind en una matriz numérica
```{r genind a matriz}
fish_geno <- tab(fish.ind, NA.method = "mean")  # convert to numeric, impute missing with mean
fish_geno <- round(fish_geno)  # make sure values are integers 0/1/2
```

### Preparando nuestros metadatos
De igual forma, cargaremos nuestro metadatos previamente filtrados:
```{r pop data}
pop_info <- readRDS(file.path("../Seccion_II/outputs", "pop_info.rds"))
strata <- pop_info
```

Además, tenemos que cargar nuestras coordenadas geográficas:
```{r coordenadas}
coords <- read.csv("../Seccion_II/datos/plectropomus_leopardus/coordinates.csv", header = TRUE)
```

Ahora, empataremos nuestras coordenadas con nuestros metadatos, tenemos que lograr que nuestros ID coincidan con su correspondiente coordenada, para ello uniremos nuestras bases:
```{r coordenadas + ID}
sample_coords <- merge(strata, coords, by = "STRATA")
```

También debemos ordenar nuestros ID en el archivo `genind` y hacer que coincida con los ID de los metadatos
```{r ID + genind}
# Ordenar para coincidir el genind/geno matrix con los IDs de las coordenadas
sample_coords <- sample_coords[match(indNames(fish.ind), sample_coords$INDIVIDUALS), ]
```

Extraeremos solamente las coordenadas geográficas:
```{r solo coordenadas}
coord_matrix <- as.matrix(sample_coords[, c("Longitude", "Latitude")])
```

Convertiremos el archivo `genind` en una matriz, esta no debe de incluir `NA` dado que la paquetería no puede tratar los datos faltantes, para ello, podemos optar por la opción de calcular la `media` para rellenar eso datos:
```{r NA datos}
fish_geno <- tab(fish.ind, NA.method = "mean")  
fish_geno <- round(fish_geno) 
```

Vamos a graficar el mapa solo con nuestros puntos de las localidades. Dado que algunas paqueterías tienen la función `map()`, vamos a forzar a R que llame la función desde la librería `maps()`, esto es necesario en este ejemplo porque hemos cargado `dplyr` de la paqutería `tidyverse` y tiene como dependencia a `purr` que enmascara nuestra función para mapear. 
```{r mapa plano}
plot(coord_matrix, pch = 19, cex = 2, 
     xlab = "Longitude (°E)", ylab = "Latitude (°N)")

maps::map("world", add = TRUE, 
          xlim = range(coord_matrix[,1]),
          ylim = range(coord_matrix[,2]))

```
Convertir el objeto `coord_matrix` en un `dataframe`
```{r matriz a dataframe}
coord_df <- as.data.frame(coord_matrix)
colnames(coord_df) <- c("lon", "lat")
```

Vamos a obtener los datos del mapa mundial para poder usarlo en nuestro gráfico mediante la función `map_data()` de la paquetería `ggplot2` y luego correremos el código para el gráfico
```{r mapa ggplot}
# mapa del mundo
world_map <- map_data("world")

# Solo la región de interés
ggplot() +
  geom_polygon(data = world_map, aes(x = long, y = lat, group = group),
               fill = "azure3", color = "gray3") +
  geom_point(data = coord_df, aes(x = lon, y = lat),
             color = "black", size = 3) +
  coord_fixed(xlim = range(coord_df$lon), ylim = range(coord_df$lat)) +
  labs(x = "Longitud (°E)", y = "Latitud (°N)") +
  theme_bw()
```





Ahora tenemos todo listo para poder correr el análisis en `tess3r`:
```{r tess3r, include=FALSE}
tess3.obj <- tess3(
  X = fish_geno,
  coord = coord_matrix,  
  K = 1:10,              
  ploidy = 2,
  method = "projected.ls",
  rep = 5
)
```

Estimaremos el coeficiente de ancestría:
```{r coeficiente}
plot(tess3.obj, pch = 19, col = "blue",
     xlab = "Number of ancestral populations",
     ylab = "Cross-validation score")
```

Dado que el gráfico anterior nos arroja una K=2, los especificaremos en nuestra `qmatrix`
```{r qmatrix}
q.matrix <- qmatrix(tess3.obj, K = 2)
```

STRUCTURE-like barplot para la matriz Q (Q-matrix)
```{r barplot, message=FALSE, warning=FALSE}
bp <- barplot(q.matrix, border = NA, space = 0, 
        xlab = "Individuos", ylab = "Proporción de ancestría") 

axis(1, at = 1:nrow(q.matrix), labels = bp$order, las = 3, cex.axis = .4) 
```

```{r paleta de colores}
my.colors <- c("tomato", "orange", "lightblue", "olivedrab")
my.palette <- CreatePalette(my.colors, 9)
```

Usaremos nuestra matriz para crear el mapa con la ancestría
```{r plot 1, warning=FALSE, message=FALSE}
plot(q.matrix, coord_matrix, method = "map.max", interpol = FieldsKrigModel(10),  
     main = "Ancestry coefficients",
     xlab = "Longitude", ylab = "Latitude", 
     resolution = c(300,300), cex = 1, 
     col.palette = my.palette)
```



Checar cuántos valores de K hay disponibles en nuestro objeto `tess3.obj`
```{r valores K}
print(length(tess3.obj))
```

Crearemos una interpolación para el océano
```{r colores interpolación}
ocean.palette <- colorRampPalette(c("darkblue", "cyan", "yellow", "red"))(100)
tps_model <- Tps(coord_matrix, q.matrix[,1])
```

```{r datos de ancestria}
x_seq <- seq(min(coord_matrix[,1])-2, max(coord_matrix[,1])+2, length.out = 200)
y_seq <- seq(min(coord_matrix[,2])-2, max(coord_matrix[,2])+2, length.out = 200)
grid_points <- as.matrix(expand.grid(x_seq, y_seq))

pred_ancestry <- predict(tps_model, grid_points)
pred_matrix <- matrix(pred_ancestry, nrow = length(x_seq), ncol = length(y_seq))
```


`ggplot2`, a diferencia de la función base de `plot` en R, requiere de un `dataframe` para leer los datos por lo que los convertiremos en antes de poder crear nuestro gráfico:
```{r dataframe interpolacion}
interp_df <- data.frame(
  x = rep(x_seq, length(y_seq)),
  y = rep(y_seq, each = length(x_seq)),
  ancestry = as.vector(pred_matrix)
)
```


Ahora crearemos un dataframe con los puntos de nuestras localidades
```{r puntos localidades}
sample_df <- data.frame(
  x = coord_matrix[,1],
  y = coord_matrix[,2],
  ancestry = q.matrix[,1]
)
```

Qué es lo que está haciendo nuestro código en esta parte?
  `x = coord_matrix[,1]`
  `y = coord_matrix[,2]`


Ahora vamos a pasar los colores al océano que es lo que nos interesa y salvaremos la figura en una buena calidad
```{r mapa ancestria océano}
ggplot() +
  # Superficie ancestral principal
  geom_tile(data = interp_df, aes(x = x, y = y, fill = ancestry), alpha = 1) +
  
  # Contornos suaves con etiquetas
  geom_contour(data = interp_df, aes(x = x, y = y, z = ancestry),
               color = "white", breaks = seq(0, 1, 0.1), linewidth = 0.4) +
  
  geom_text_contour(data = interp_df, aes(x = x, y = y, z = ancestry),
                    color = "white", size = 3, check_overlap = TRUE,
                    breaks = seq(0, 1, 0.1)) +
  
  # Localidades de las muestras
  geom_point(data = sample_df, aes(x = x, y = y),
             color = "black", fill = "white", shape = 21, size = 2.5, stroke = 0.8) +
  
  # Estilo del gráfico y aplicación de colores
  scale_fill_gradientn(colors = ocean.palette,
                       limits = c(0, 1),
                       name = "Proporción de\nAncestría",
                       na.value = "transparent") +
  coord_fixed(xlim = range(x_seq), ylim = range(y_seq)) +
  labs(x = "Longitud", y = "Latitud") +
  theme_bw() +
  theme(
    panel.background = element_rect(fill = "white"),
    panel.grid = element_line(color = "gray80")
  ) +

  # Superposición del continente al final para que cubra todo lo que hay debajo, en este caso los colores de ancestría
  geom_polygon(data = world_map, aes(x = long, y = lat, group = group),
               fill = "azure3", color = "gray3")

# ggsave("ancestria.png", width = 8, height = 6, dpi = 300)
```


Vamos a graficar los resultados de ancestría por cluster, para ello encontraremos al cluster dominante para cada muestra
```{r clusters dominantes}
dominant_cluster <- apply(q.matrix, 1, which.max)

sample_df_dominant <- data.frame(
  x = coord_matrix[,1],
  y = coord_matrix[,2],
  cluster = factor(dominant_cluster)
)
```

Ahora asignaremos los colores a cada cluster, como no sabemos cuántos tenemos, asignaremos 4 colores, pero pueden ser más y graficaremos.
```{r mapa clusters puntos}
cluster_colors <- c("red", "blue", "green", "purple", "orange")[1:ncol(q.matrix)]

ggplot() +
  geom_tile(data = interp_df, aes(x = x, y = y), fill = "transparent") +
  geom_point(data = sample_df_dominant, aes(x = x, y = y, color = cluster), 
             size = 3, alpha = 0.8) +
  geom_polygon(data = world_map, aes(x = long, y = lat, group = group),
               fill = "gray40", color = "black", alpha = 0.7) +
  scale_color_manual(values = cluster_colors, name = "Cluster\ndominante") +
  coord_fixed(xlim = range(x_seq), ylim = range(y_seq)) +
  labs(x = "Longitud", y = "Latitud") +
  theme_bw()
```
Dado que se mostraron dos (K=2), crearemos una paleta de colores que representen a cada uno de los encontrados, agregando un color intermedio para balancear y representarlos mejor.
```{r paleta balance}
balance.palette <- colorRampPalette(c("blue", "white", "red"))(100)
```

Usaremos la proporción del cluster 1 como nuestra variable principal
```{r cluster principal}
tps_model <- Tps(coord_matrix, q.matrix[,1])
```

```{r datos cluster principal}
pred_ancestry <- predict(tps_model, grid_points)
pred_matrix <- matrix(pred_ancestry, nrow = length(x_seq), ncol = length(y_seq))
```


De nuevo, los correspondientes dataframe para cada sección, la interpolación y las muestras.
```{r interpolacion y muestras K}
interp_df <- data.frame(
  x = rep(x_seq, length(y_seq)),
  y = rep(y_seq, each = length(x_seq)),
  cluster1_proportion = as.vector(pred_matrix)  # Proportion of Cluster 1
)

sample_df <- data.frame(
  x = coord_matrix[,1],
  y = coord_matrix[,2],
  cluster1_proportion = q.matrix[,1],  
  cluster2_proportion = q.matrix[,2]  
) 
```

Y ahora, graficamos por cluster
```{r mapa ancestria clusters}
ggplot() +
  geom_tile(data = interp_df, aes(x = x, y = y, fill = cluster1_proportion), alpha = 0.8) +
  geom_contour(data = interp_df, aes(x = x, y = y, z = cluster1_proportion),
               color = "white", breaks = seq(0, 1, 0.1), linewidth = 0.3) +
    scale_fill_gradientn(colors = balance.palette,
                       limits = c(0, 1),
                       na.value = "transparent",
                       name = "Cluster Balance",
                       breaks = c(0, 0.5, 1),
                       labels = c("Cluster 2\nDominant", "Equal", "Cluster 1\nDominant")) +
  coord_fixed(xlim = range(x_seq), ylim = range(y_seq)) +
  labs(title = "Estructura poblacional - K=2 Clusters",
       subtitle = "Azul: Cluster dominante 1 | Rojo: Cluster dominante 2",
       x = "Longitude", y = "Latitude") +
  theme_bw() +
  theme(
    panel.background = element_rect(fill = "transparent"),
    panel.grid = element_line(color = "gray80")
  ) +
  geom_polygon(data = world_map, aes(x = long, y = lat, group = group),
               fill = "azure3", color = "gray3") +
  geom_point(data = sample_df, aes(x = x, y = y, fill = cluster1_proportion),
             color = "black", shape = 21, size = 2.5, stroke = 0.8) 
```
