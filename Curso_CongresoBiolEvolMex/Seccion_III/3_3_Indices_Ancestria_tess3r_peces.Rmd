---
title: "Indices de ancestría en `tess3r`"
author: "Daniela Felix"
output:
  html_document:
    css: styles.css
    toc: true
    toc_float: true
date: "`r Sys.Date()`"
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r include=FALSE}
library(adegenet)
library(tess3r)
library(maps)
library(ggplot2)
library(sf)
library(rnaturalearth)
library(rworldmap)
library(fields)
library(metR)
```

### Preparando nuestros datos genéticos
```{r objeto genind}
fish.ind <- readRDS(file.path("../Seccion_II/outputs/", "fish.ind.rds"))
fish.ind
```

Convertir nuestro objeto genind en una matriz numérica
```{r}
fish_geno <- tab(fish.ind, NA.method = "mean")  # convert to numeric, impute missing with mean
fish_geno <- round(fish_geno)  # make sure values are integers 0/1/2
```

### Preparando nuestros metadatos
De igual forma, cargaremos nuestro metadatos previamente filtrados:
```{r}
pop_info <- readRDS(file.path("../Seccion_II/outputs", "pop_info.rds"))
strata <- pop_info
```

Además, tenemos que cargar nuestras coordenadas geográficas:
```{r}
coords <- read.csv("../Seccion_II/datos/plectropomus_leopardus/coordinates.csv", header = TRUE)
```

Ahora, empataremos nuestras coordenadas con nuestros metadatos, tenemos que lograr que nuestros ID coincidan con su correspondiente coordenada, para ello uniremos nuestras bases:
```{r}
sample_coords <- merge(strata, coords, by = "STRATA")
```

También debemos ordenar nuestros ID en el archivo `genind` y hacer que coincida con los ID de los metadatos
```{r}
# Order to match the genind/geno matrix
sample_coords <- sample_coords[match(indNames(fish.ind), sample_coords$INDIVIDUALS), ]
```

Extraeremos solamente las coordenadas geográficas:
```{r}
coord_matrix <- as.matrix(sample_coords[, c("Longitude", "Latitude")])
```

Convertiremos el archivo `genind` en una matriz, esta no debe de incluir `NA` dado que la paquetería no puede tratar los datos faltantes, para ello, podemos optar por la opción de calcular la `media` para rellenar eso datos:
```{r}
fish_geno <- tab(fish.ind, NA.method = "mean")  
fish_geno <- round(fish_geno) 
```


```{r}
plot(coord_matrix, pch = 19, cex = .5, 
     xlab = "Longitude (°E)", ylab = "Latitude (°N)")
map(add = TRUE, interior = FALSE)
```


Ahora tenemos todo listo para poder correr el análisis en `tess3r`:
```{r include=FALSE}
tess3.obj <- tess3(
  X = fish_geno,
  coord = coord_matrix,  
  K = 1:10,              
  ploidy = 2,
  method = "projected.ls",
  rep = 5
)
```

Estimaremos el coeficiente de ancestría:
```{r}
plot(tess3.obj, pch = 19, col = "blue",
     xlab = "Number of ancestral populations",
     ylab = "Cross-validation score")
```

Dado que el gráfico anterior nos arroja una K=2, los especificaremos en nuestra `qmatrix`
```{r}
q.matrix <- qmatrix(tess3.obj, K = 2)
```

STRUCTURE-like barplot for the Q-matrix
```{r barplot, message=FALSE, warning=FALSE}
barplot(q.matrix, border = NA, space = 0, 
        xlab = "Individuals", ylab = "Ancestry proportions", 
        main = "Ancestry matrix") -> bp

axis(1, at = 1:nrow(q.matrix), labels = bp$order, las = 3, cex.axis = .4) 
```

```{r}
my.colors <- c("tomato", "orange", "lightblue", "olivedrab")
my.palette <- CreatePalette(my.colors, 9)
```

Usaremos nuestra matriz para crear el mapa con la ancestría
```{r plot 1, warning=FALSE, message=FALSE}
plot(q.matrix, coord_matrix, method = "map.max", interpol = FieldsKrigModel(10),  
     main = "Ancestry coefficients",
     xlab = "Longitude", ylab = "Latitude", 
     resolution = c(300,300), cex = .4, 
     col.palette = my.palette)
```



```{r}
plot(coord_matrix[,1], coord_matrix[,2], type = "n",
     xlab = "Longitude", ylab = "Latitude",
     main = "Population Structure - Marine Samples")

# Ocean background
rect(par("usr")[1], par("usr")[3], par("usr")[2], par("usr")[4], 
     col = "lightblue", border = NA)

# Create simple colors directly
ancestry_colors <- rgb(
  red = q.matrix[,1],    # Red component = ancestry cluster 1
  green = 1 - q.matrix[,1], # Green component = inverse of cluster 1
  blue = 0.5,            # Fixed blue component
  alpha = 0.8
)

# Add colored points
points(coord_matrix[,1], coord_matrix[,2], 
       pch = 21, bg = ancestry_colors, col = "black", 
       cex = 2, lwd = 1.5)

# Add land
map("world", add = TRUE, col = "lightgreen", fill = TRUE, border = "darkgreen")

# Simple legend
legend_colors <- rgb(
  red = c(0, 0.5, 1),
  green = c(1, 0.5, 0), 
  blue = c(0.5, 0.5, 0.5)
)

legend("topright", 
       title = "Ancestry Cluster 1",
       legend = c("Low (0)", "Medium (0.5)", "High (1)"),
       pch = 21, pt.bg = legend_colors,
       pt.cex = 1.5, bty = "n")

grid()
```

Vamos a crear una paleta de colores a utilizar en el océano, especificaremos los colores y la cantidad que necesitaremos
```{r ocean colours}
ocean.palette <- colorRampPalette(c("darkblue", "cyan", "yellow", "red"))(100)
# ocean.palette <- colorRampPalette(c("darkblue",  "red"))(50)

```

Create interpolation surface for ancestry in the ocean
```{r}
tps_model <- Tps(coord_matrix, q.matrix[,1])

# 3. Create a detailed grid covering your ocean area
x_seq <- seq(min(coord_matrix[,1])-2, max(coord_matrix[,1])+2, length.out = 200)
y_seq <- seq(min(coord_matrix[,2])-2, max(coord_matrix[,2])+2, length.out = 200)
grid_points <- as.matrix(expand.grid(x_seq, y_seq))

# 4. Predict ancestry values across the entire grid
pred_ancestry <- predict(tps_model, grid_points)
pred_matrix <- matrix(pred_ancestry, nrow = length(x_seq), ncol = length(y_seq))
```



```{r}
# Añade primero la interpolación de ancestría (esto coloreará el océano)
image(x_seq, y_seq, pred_matrix, 
      col = ocean.palette, 
      zlim = c(0, 1),
      xlab = "", ylab = "", add = FALSE)  # Don't use add=TRUE here

# Agregar las isolíneas para mostrar el gradiente de ancestría
contour(x_seq, y_seq, pred_matrix, 
        levels = seq(0, 1, 0.1),
        add = TRUE, drawlabels = TRUE, 
        col = "white", lwd = 0.8, labcex = 0.7)


# En este paso agregaremos la tierra sobre la ancestría (para cubrir los colores)
map("world", add = TRUE, col = "gray", fill = TRUE, border = "black")


# Ahora los puntos en color blanco
points(coord_matrix[,1], coord_matrix[,2], 
       pch = 21, bg = "white", col = "black", cex = 1.2, lwd = 1)


image.plot(zlim = c(0, 1), 
           col = ocean.palette,
           legend.only = TRUE,
           horizontal = FALSE,
           legend.args = list(text = "Ancestry\nProportion", 
                             side = 4, line = 2.5, cex = 0.9),
           smallplot = c(0.88, 0.91, 0.2, 0.8))


# Ahora el grid
grid()
```

Checar cuántos valores de K hay disponibles en nuestro objeto `tess3.obj`
```{r}
print(length(tess3.obj))
```


```{r}
library(metR)
# 1. Create interpolation (same as before)
ocean.palette <- colorRampPalette(c("darkblue", "cyan", "yellow", "red"))(100)
tps_model <- Tps(coord_matrix, q.matrix[,1])
```

```{r}
x_seq <- seq(min(coord_matrix[,1])-2, max(coord_matrix[,1])+2, length.out = 200)
y_seq <- seq(min(coord_matrix[,2])-2, max(coord_matrix[,2])+2, length.out = 200)
grid_points <- as.matrix(expand.grid(x_seq, y_seq))

pred_ancestry <- predict(tps_model, grid_points)
pred_matrix <- matrix(pred_ancestry, nrow = length(x_seq), ncol = length(y_seq))

# 2. Convert to data frame for ggplot
interp_df <- data.frame(
  x = rep(x_seq, length(y_seq)),
  y = rep(y_seq, each = length(x_seq)),
  ancestry = as.vector(pred_matrix)
)

# 3. Get world map data using map_data() instead of fortify()
world_map <- map_data("world")

# 4. Create sample points data
sample_df <- data.frame(
  x = coord_matrix[,1],
  y = coord_matrix[,2],
  ancestry = q.matrix[,1]
)

# 5. Create the ggplot
ggplot() +
  # Main ancestry surface
  geom_tile(data = interp_df, aes(x = x, y = y, fill = ancestry), alpha = 0.8) +
  
  # Smooth contour lines with labels
  geom_contour(data = interp_df, aes(x = x, y = y, z = ancestry),
               color = "white", breaks = seq(0, 1, 0.1), linewidth = 0.3) +
  
  geom_text_contour(data = interp_df, aes(x = x, y = y, z = ancestry),
                    color = "white", size = 3, check_overlap = TRUE,
                    breaks = seq(0, 1, 0.1)) +
  
  # Land overlay
  geom_polygon(data = world_map, aes(x = long, y = lat, group = group),
               fill = "gray40", color = "black", alpha = 0.7) +
  
  # Sample locations
  geom_point(data = sample_df, aes(x = x, y = y),
             color = "black", fill = "white", shape = 21, size = 2.5, stroke = 0.8) +
  
  # Styling
  scale_fill_gradientn(colors = ocean.palette,
                       limits = c(0, 1),
                       name = "Ancestry\nProportion") +
  coord_fixed(xlim = range(x_seq), ylim = range(y_seq)) +
  labs(title = "Population Structure - Marine Environment",
       x = "Longitude", y = "Latitude") +
  theme_bw() +
  theme(
    panel.background = element_rect(fill = "white"),
    panel.grid = element_line(color = "gray80")
  )
```

```{r}
# Create plots for each ancestry component
for (k in 1:ncol(q.matrix)) {
  
  tps_model <- Tps(coord_matrix, q.matrix[,k])
  pred_ancestry <- predict(tps_model, grid_points)
  pred_matrix <- matrix(pred_ancestry, nrow = length(x_seq), ncol = length(y_seq))
  
  interp_df <- data.frame(
    x = rep(x_seq, length(y_seq)),
    y = rep(y_seq, each = length(x_seq)),
    ancestry = as.vector(pred_matrix)
  )
  
  p <- ggplot() +
    geom_tile(data = interp_df, aes(x = x, y = y, fill = ancestry), alpha = 0.8) +
    geom_contour(data = interp_df, aes(x = x, y = y, z = ancestry),
                 color = "white", breaks = seq(0, 1, 0.1), linewidth = 0.3) +
    geom_polygon(data = world_map, aes(x = long, y = lat, group = group),
                 fill = "gray40", color = "black", alpha = 0.7) +
    geom_point(data = sample_df, aes(x = x, y = y),
               color = "black", fill = "white", shape = 21, size = 1.5) +
    scale_fill_gradientn(colors = ocean.palette, limits = c(0, 1),
                         name = paste("Cluster", k)) +
    coord_fixed(xlim = range(x_seq), ylim = range(y_seq)) +
    labs(title = paste("Ancestry Cluster", k),
         x = "Longitude", y = "Latitude") +
    theme_bw()
  
  print(p)
}
```
```{r}
# Find dominant cluster for each sample
dominant_cluster <- apply(q.matrix, 1, which.max)

sample_df_dominant <- data.frame(
  x = coord_matrix[,1],
  y = coord_matrix[,2],
  cluster = factor(dominant_cluster)
)

# Create colors for each cluster
cluster_colors <- c("red", "blue", "green", "purple", "orange")[1:ncol(q.matrix)]

ggplot() +
  geom_tile(data = interp_df, aes(x = x, y = y), fill = "lightblue") +
  geom_point(data = sample_df_dominant, aes(x = x, y = y, color = cluster), 
             size = 3, alpha = 0.8) +
  geom_polygon(data = world_map, aes(x = long, y = lat, group = group),
               fill = "gray40", color = "black", alpha = 0.7) +
  scale_color_manual(values = cluster_colors, name = "Dominant\nCluster") +
  coord_fixed(xlim = range(x_seq), ylim = range(y_seq)) +
  labs(title = "Dominant Ancestry Cluster",
       x = "Longitude", y = "Latitude") +
  theme_bw()
```

```{r}
library(ggplot2)
library(fields)
library(maps)

# Since K=2, we can show the balance between the two clusters
# Let's use: Blue = high Cluster 1, Red = high Cluster 2

# Create color palette for the balance
balance.palette <- colorRampPalette(c("blue", "white", "red"))(100)

# Use Cluster 1 proportion as our main variable (Cluster 2 is 1 - Cluster 1)
tps_model <- Tps(coord_matrix, q.matrix[,1])  # Using Cluster 1 proportions

x_seq <- seq(min(coord_matrix[,1])-2, max(coord_matrix[,1])+2, length.out = 200)
y_seq <- seq(min(coord_matrix[,2])-2, max(coord_matrix[,2])+2, length.out = 200)
grid_points <- as.matrix(expand.grid(x_seq, y_seq))

pred_ancestry <- predict(tps_model, grid_points)
pred_matrix <- matrix(pred_ancestry, nrow = length(x_seq), ncol = length(y_seq))

interp_df <- data.frame(
  x = rep(x_seq, length(y_seq)),
  y = rep(y_seq, each = length(x_seq)),
  cluster1_proportion = as.vector(pred_matrix)  # Proportion of Cluster 1
)

world_map <- map_data("world")

sample_df <- data.frame(
  x = coord_matrix[,1],
  y = coord_matrix[,2],
  cluster1_proportion = q.matrix[,1],  # Proportion of Cluster 1
  cluster2_proportion = q.matrix[,2]   # Proportion of Cluster 2
)

# Create the plot
ggplot() +
  # Interpolation surface - Blue (Cluster 1) to Red (Cluster 2)
  geom_tile(data = interp_df, aes(x = x, y = y, fill = cluster1_proportion), alpha = 0.8) +
  
  # Contour lines
  geom_contour(data = interp_df, aes(x = x, y = y, z = cluster1_proportion),
               color = "white", breaks = seq(0, 1, 0.1), linewidth = 0.3) +
  
  # Land overlay
  geom_polygon(data = world_map, aes(x = long, y = lat, group = group),
               fill = "gray40", color = "black", alpha = 0.7) +
  
  # Sample points colored by their cluster balance
  geom_point(data = sample_df, aes(x = x, y = y, fill = cluster1_proportion),
             color = "black", shape = 21, size = 2.5, stroke = 0.8) +
  
  # Color scale: Blue = Cluster 1 dominant, Red = Cluster 2 dominant
  scale_fill_gradientn(colors = balance.palette,
                       limits = c(0, 1),
                       name = "Cluster Balance",
                       breaks = c(0, 0.5, 1),
                       labels = c("Cluster 2\nDominant", "Equal", "Cluster 1\nDominant")) +
  
  coord_fixed(xlim = range(x_seq), ylim = range(y_seq)) +
  labs(title = "Population Structure - K=2 Clusters",
       subtitle = "Blue: Cluster 1 dominant | Red: Cluster 2 dominant",
       x = "Longitude", y = "Latitude") +
  theme_bw() +
  theme(
    panel.background = element_rect(fill = "lightblue"),
    panel.grid = element_line(color = "gray80")
  )
```

